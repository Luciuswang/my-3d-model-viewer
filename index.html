<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Three.js FBX模型多视图</title>
  <style>
    /* 固定容器高度500px，宽度100%自适应 */
    #modelViewer1, #modelViewer2, #modelViewer3 {
      width: 100%;
      height: 500px;
      display: inline-block;  /* 可根据需要调整布局，inline-block可使多个容器横排 */
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <!-- 三个模型显示容器 -->
  <div id="modelViewer1"></div>
  <div id="modelViewer2"></div>
  <div id="modelViewer3"></div>

  <!-- 引入Three.js库、控制器和加载器脚本（假设文件位于同目录） -->
  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>
  <script src="FBXLoader.js"></script>

  <!-- 主脚本：初始化三个模型场景并加载模型 -->
  <script>
    // 创建一个模型查看器，对指定容器加载指定FBX模型
    function createViewer(containerId, modelFile) {
      const container = document.getElementById(containerId);
      const width = container.clientWidth;
      const height = container.clientHeight;

      // 场景与相机
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xeeeeee);  // 背景色浅灰
      const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
      camera.position.set(0, 100, 200);             // 初始相机位置 (可根据模型大小调整)
      camera.lookAt(scene.position);                // 相机朝向场景中心 (0,0,0)

      // 基础光源：环境光+方向光
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50);
      scene.add(dirLight);

      // 渲染器设置
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // 轨道控制器
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);   // 围绕原点旋转（假设模型在原点附近）
      controls.update();              // 更新一次控制器（摄像机朝向）

      // 异步加载FBX模型
      const loader = new THREE.FBXLoader();
      loader.load(modelFile, function(object) {
        scene.add(object);
        // 如果模型尺寸不合适，这里可以调整object的scale或position
        // 例如：object.scale.set(0.5, 0.5, 0.5);
      }, undefined, function(error) {
        console.error("加载模型出现错误:", error);
      });

      // 渲染动画循环
      function animate() {
        requestAnimationFrame(animate);
        controls.update();               // 更新OrbitControls（包含阻尼效果）
        renderer.render(scene, camera);  // 渲染当前场景
      }
      animate();  // 启动动画循环
    }

    // 初始化三个模型视图
    createViewer('modelViewer1', 'model1.fbx');
    createViewer('modelViewer2', 'model2.fbx');
    createViewer('modelViewer3', 'model3.fbx');

    // （可选）根据窗口大小调整摄像机和渲染器
    window.addEventListener('resize', function() {
      // 针对每个Viewer都更新，这里简单处理:
      const containers = ['modelViewer1','modelViewer2','modelViewer3'];
      containers.forEach(id => {
        const container = document.getElementById(id);
        const canvas = container.querySelector('canvas');
        if (canvas) {
          // 获取对应viewer的场景组件（这需要在createViewer中暴露camera和renderer或保存它们）
          // 简化处理：重新设置canvas大小
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
        }
      });
      // 说明：更严格的实现应维护每个viewer的camera和renderer对象，然后在此更新camera.aspect等。
    });
  </script>
</body>
</html>
